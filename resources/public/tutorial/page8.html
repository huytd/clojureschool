<p>Yay! Chạy được luôn! <img width=18 src="http://emoji-cheat-sheet.com/graphics/emojis/grin.png"/></p>

<p>Giờ chắc bạn đang nghĩ Clojure rất khác so với những ngôn ngữ lập trình mà bạn đã từng biết đúng không? Thực ra thì đúng là như vậy đó <img width=18 src="http://emoji-cheat-sheet.com/graphics/emojis/joy.png"/></p>

<p>Thằng Clojure là con của một "gia đình" mà có lẽ bạn cũng đã từng nghe qua, họ nhà "functional" programming languages - các ngôn ngữ lập trình hàm.</p>

<p>Và cũng giống như mọi ngôn ngữ lập trình hàm khác, Clojure có thể định nghĩa một hàm mà không cần đặt tên cho nó (anonymous function): <code class="expr">(fn [x] (* x x))</code></p>

<p>Nếu bạn chạy đoạn code trên, bạn sẽ thấy những dòng output rất là huyền bí <img width=18 src="http://emoji-cheat-sheet.com/graphics/emojis/sob.png"/></p>
<p>Trong Clojure, hàm cũng là các giá trị thông thường giống như số (number) hoặc chuỗi (string). <code>fn</code> định nghĩa ra một hàm và trả về giá trị của nó. Và output mà bạn vừa nhìn thấy thực chất là hàm mà bạn vừa tạo ra, được thể hiện dưới dạng chuỗi in ra trên màn hình.</p>

<p>Nhưng mà khoan! Tạo ra một hàm anonymous thì có tác dụng gì khi mà bạn không gọi được nó? Hãy thử định nghĩa một hàm anonymous và gọi nó ngay lập tức như thế này: <code class="expr">((fn [x] (* x x)) 10)</code>.
</p>
